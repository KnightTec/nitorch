import torch
from nitorch.core import utils, constants
from .noise import add_noise


def mprage(pd, r1, r2s=None, transmit=None, receive=None, gfactor=None,
           te=3e-3, tr=2.3, ti=0.9, fa=9, n=100, sigma=None, device=None):
    """Simulate data generated by a (simplified) MP-RAGE sequence.

    Default parameters mimic the ADNI-3 protocol on 3T Siemens scanners.

    Tissue parameters
    -----------------
    pd : tensor_like
        Proton density
    r1 : tensor_like
        Longitudinal relaxation rate, in 1/sec
    r2s : tensor_like, optional
        Transverse relaxation rate, in 1/sec.
        If not provided, T2*-bias is not included.

    Fields
    ------
    transmit : tensor_like, optional
        Transmit B1 field
    receive : tensor_like, optional
        Receive B1 field
    gfactor : tensor_like, optional
        G-factor map.
        If provided and `sigma` is not `None`, the g-factor map is used
        to sample non-stationary noise.

    Sequence parameters
    -------------------
    te : float, default=3e-3
        Echo time, in sec
    tr : float default=2.3
        Repetition time, in sec.
    ti : float, default=0.9
        Inversion time, in sec.
    fa : float, default=9
        Flip angle, in deg
    n : int, default=100

    Noise
    -----
    sigma : float, optional
        Standard-deviation of the sampled Rician noise (no sampling if `None`)

    Returns
    -------
    sim : tensor
        Simulated MPRAGE image

    """

    pd, r1, r2s, transmit, receive, gfactor \
        = utils.to_max_backend(pd, r1, r2s, transmit, receive, gfactor)
    pd, r1, r2s, transmit, receive, gfactor \
        = utils.to(pd, r1, r2s, transmit, receive, gfactor, device=device)
    backend = utils.backend(pd)

    tp = 2*te                       # Time between excitation pulses
    fa = fa * constants.pi / 180    # Flip angle
    n = n or min(pd.shape)          # Number of readouts (PE steps) per loop
    n = n // 2                      # Middle of k-space
    td = tr - ti - 2*n*tp           # Recovery time

    if transmit is not None:
        fa = transmit * fa
    del transmit
    fa = torch.as_tensor(fa, **backend)

    if receive is not None:
        pd = pd * receive
    del receive
    pd = pd * fa.sin()
    fa = fa.cos()

    ep = r1.mul(tp).neg_().exp_()
    ei = r1.mul(ti).neg_().exp_()
    e1 = r1.mul(tr).neg_().exp_()
    ed = r1.mul(td).neg_().exp_()
    del r1

    # signal
    signal = (1 - ep) * (1 - (ep*fa) ** (n-1)) / (1 - ep * fa)
    e1 *= fa ** (2*n - 1)
    signal += ep * (1 - ei)
    signal_td = ed.neg()
    signal_td += fa*ed * (1-ep) * (1 - (fa*ep)**(2*n-1)) / (1 - fa*ep)
    signal_td += fa*ed * ((fa*ep)**(2*n-1))
    signal += ep * ei * (1 - e1 + signal_td) / (1 + e1)
    del ei, ep, signal_td
    signal *= pd
    del pd

    # T2* bias
    if r2s is not None:
        e2 = r2s.mul(te).neg_().exp_()
        signal *= e2
    del r2s

    # noise
    signal = add_noise(signal, std=sigma)

    return signal


